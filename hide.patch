--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -92,6 +92,7 @@
 #include <linux/fs_struct.h>
 #include <linux/kthread.h>
 #include <linux/mmu_context.h>
+#include <linux/ctype.h>
 
 #include <asm/processor.h>
 #include "internal.h"
@@ -152,6 +153,8 @@
 	struct group_info *group_info;
 	int g, umask = -1;
 	struct task_struct *tracer;
+	char tracer_comm[TASK_COMM_LEN] = { 0 };
+	char tracer_comm_lc[TASK_COMM_LEN] = { 0 };
 	const struct cred *cred;
 	pid_t ppid, tpid = 0, tgid, ngid;
 	unsigned int max_fds = 0;
@@ -161,8 +164,14 @@
 		task_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;
 
 	tracer = ptrace_parent(p);
-	if (tracer)
+	if (tracer) {
 		tpid = task_pid_nr_ns(tracer, ns);
+		get_task_comm(tracer_comm, tracer);
+		/* Lowercase copy for case-insensitive matching */
+		for (g = 0; g < TASK_COMM_LEN - 1 && tracer_comm[g]; g++)
+			tracer_comm_lc[g] = tolower(tracer_comm[g]);
+		tracer_comm_lc[g] = '\0';
+	}
 
 	tgid = task_tgid_nr_ns(p, ns);
 	ngid = task_numa_group_id(p);
@@ -178,14 +187,24 @@
 
 	if (umask >= 0)
 		seq_printf(m, "Umask:\t%#04o\n", umask);
-	seq_puts(m, "State:\t");
-	seq_puts(m, get_task_state(p));
+    seq_puts(m, "State:\t");
+    {
+        const char *state = get_task_state(p);
+        if (state && !strcmp(state, "S (sleeping)"))
+            state = "R (running)";
+        seq_puts(m, state);
+    }
 
 	seq_put_decimal_ull(m, "\nTgid:\t", tgid);
 	seq_put_decimal_ull(m, "\nNgid:\t", ngid);
 	seq_put_decimal_ull(m, "\nPid:\t", pid_nr_ns(pid, ns));
 	seq_put_decimal_ull(m, "\nPPid:\t", ppid);
-	seq_put_decimal_ull(m, "\nTracerPid:\t", tpid);
+	if (tpid && (strnstr(tracer_comm_lc, "frida", TASK_COMM_LEN) ||
+	            strnstr(tracer_comm_lc, "gadget", TASK_COMM_LEN))) {
+		seq_put_decimal_ull(m, "\nTracerPid:\t", 0);
+	} else {
+		seq_put_decimal_ull(m, "\nTracerPid:\t", tpid);
+	}
 	seq_put_decimal_ull(m, "\nUid:\t", from_kuid_munged(user_ns, cred->uid));
 	seq_put_decimal_ull(m, "\t", from_kuid_munged(user_ns, cred->euid));
 	seq_put_decimal_ull(m, "\t", from_kuid_munged(user_ns, cred->suid));
@@ -486,6 +505,9 @@
 	unsigned int seq = 1;
 
 	state = *get_task_state(task);
+	/* Hide tracing stop in /proc/<pid>/stat: 't' -> 'S' */
+	if (state == 't')
+		state = 'S';
 	vsize = eip = esp = 0;
 	permitted = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);
 	mm = get_task_mm(task);
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -438,21 +438,26 @@
 static int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,
 			  struct pid *pid, struct task_struct *task)
 {
-	unsigned long wchan;
-	char symname[KSYM_NAME_LEN];
+    unsigned long wchan;
+    char symname[KSYM_NAME_LEN];
 
-	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
-		goto print0;
+    if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
+        goto print0;
 
-	wchan = get_wchan(task);
-	if (wchan && !lookup_symbol_name(wchan, symname)) {
-		seq_puts(m, symname);
-		return 0;
-	}
+    wchan = get_wchan(task);
+    if (wchan && !lookup_symbol_name(wchan, symname)) {
+        if (!strcmp(symname, "ptrace_stop")) {
+            pr_info("inject-hide: proc_pid_wchan called, wchan: %s\n", symname);
+            seq_putc(m, '0');
+        } else {
+            seq_puts(m, symname);
+        }
+        return 0;
+    }
 
 print0:
-	seq_putc(m, '0');
-	return 0;
+    seq_putc(m, '0');
+    return 0;
 }
 #endif /* CONFIG_KALLSYMS */
 
