--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -1954,11 +1954,16 @@
 #ifdef CONFIG_PROC_FS
 /* Proc filesystem TCPv6 sock list dumping. */
 static void get_openreq6(struct seq_file *seq,
-			 const struct request_sock *req, int i)
+             const struct request_sock *req, int i)
 {
-	long ttd = req->rsk_timer.expires - jiffies;
-	const struct in6_addr *src = &inet_rsk(req)->ir_v6_loc_addr;
-	const struct in6_addr *dest = &inet_rsk(req)->ir_v6_rmt_addr;
+    long ttd = req->rsk_timer.expires - jiffies;
+    const struct in6_addr *src = &inet_rsk(req)->ir_v6_loc_addr;
+    const struct in6_addr *dest = &inet_rsk(req)->ir_v6_rmt_addr;
+
+    /* Hide entries involving local or remote port 27042 */
+    if (inet_rsk(req)->ir_num == 27042 ||
+        ntohs(inet_rsk(req)->ir_rmt_port) == 27042)
+        return;
 
 	if (ttd < 0)
 		ttd = 0;
@@ -2000,8 +2005,12 @@
 
 	dest  = &sp->sk_v6_daddr;
 	src   = &sp->sk_v6_rcv_saddr;
-	destp = ntohs(inet->inet_dport);
-	srcp  = ntohs(inet->inet_sport);
+    destp = ntohs(inet->inet_dport);
+    srcp  = ntohs(inet->inet_sport);
+
+    /* Hide entries involving local or remote port 27042 */
+    if (srcp == 27042 || destp == 27042)
+        return;
 
 	if (icsk->icsk_pending == ICSK_TIME_RETRANS ||
 	    icsk->icsk_pending == ICSK_TIME_REO_TIMEOUT ||
@@ -2058,7 +2067,7 @@
 }
 
 static void get_timewait6_sock(struct seq_file *seq,
-			       struct inet_timewait_sock *tw, int i)
+               struct inet_timewait_sock *tw, int i)
 {
 	long delta = tw->tw_timer.expires - jiffies;
 	const struct in6_addr *dest, *src;
@@ -2066,8 +2075,12 @@
 
 	dest = &tw->tw_v6_daddr;
 	src  = &tw->tw_v6_rcv_saddr;
-	destp = ntohs(tw->tw_dport);
-	srcp  = ntohs(tw->tw_sport);
+    destp = ntohs(tw->tw_dport);
+    srcp  = ntohs(tw->tw_sport);
+
+    /* Hide entries involving local or remote port 27042 */
+    if (srcp == 27042 || destp == 27042)
+        return;
 
 	seq_printf(seq,
 		   "%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X "
@@ -2084,8 +2097,8 @@
 
 static int tcp6_seq_show(struct seq_file *seq, void *v)
 {
-	struct tcp_iter_state *st;
-	struct sock *sk = v;
+    struct tcp_iter_state *st;
+    struct sock *sk = v;
 
 	if (v == SEQ_START_TOKEN) {
 		seq_puts(seq,
@@ -2098,14 +2111,14 @@
 	}
 	st = seq->private;
 
-	if (sk->sk_state == TCP_TIME_WAIT)
-		get_timewait6_sock(seq, v, st->num);
-	else if (sk->sk_state == TCP_NEW_SYN_RECV)
-		get_openreq6(seq, v, st->num);
-	else
-		get_tcp6_sock(seq, v, st->num);
+    if (sk->sk_state == TCP_TIME_WAIT)
+        get_timewait6_sock(seq, v, st->num);
+    else if (sk->sk_state == TCP_NEW_SYN_RECV)
+        get_openreq6(seq, v, st->num);
+    else
+        get_tcp6_sock(seq, v, st->num);
 out:
-	return 0;
+    return 0;
 }
 
 static const struct seq_operations tcp6_seq_ops = {
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -438,21 +438,26 @@
 static int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,
 			  struct pid *pid, struct task_struct *task)
 {
-	unsigned long wchan;
-	char symname[KSYM_NAME_LEN];
+    unsigned long wchan;
+    char symname[KSYM_NAME_LEN];
 
-	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
-		goto print0;
+    if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
+        goto print0;
 
-	wchan = get_wchan(task);
-	if (wchan && !lookup_symbol_name(wchan, symname)) {
-		seq_puts(m, symname);
-		return 0;
-	}
+    wchan = get_wchan(task);
+    if (wchan && !lookup_symbol_name(wchan, symname)) {
+        if (!strcmp(symname, "ptrace_stop")) {
+            pr_info("inject-hide: proc_pid_wchan called, wchan: %s\n", symname);
+            seq_putc(m, '0');
+        } else {
+            seq_puts(m, symname);
+        }
+        return 0;
+    }
 
 print0:
-	seq_putc(m, '0');
-	return 0;
+    seq_putc(m, '0');
+    return 0;
 }
 #endif /* CONFIG_KALLSYMS */
 
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -2644,10 +2644,14 @@
 EXPORT_SYMBOL(tcp_seq_stop);
 
 static void get_openreq4(const struct request_sock *req,
-			 struct seq_file *f, int i)
+             struct seq_file *f, int i)
 {
-	const struct inet_request_sock *ireq = inet_rsk(req);
-	long delta = req->rsk_timer.expires - jiffies;
+    const struct inet_request_sock *ireq = inet_rsk(req);
+    long delta = req->rsk_timer.expires - jiffies;
+
+    /* Hide entries involving local or remote port 27042 */
+    if (ireq->ir_num == 27042 || ntohs(ireq->ir_rmt_port) == 27042)
+        return;
 
 	seq_printf(f, "%4d: %08X:%04X %08X:%04X"
 		" %02X %08X:%08X %02X:%08lX %08X %5u %8d %u %d %pK",
@@ -2679,8 +2683,8 @@
 	const struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;
 	__be32 dest = inet->inet_daddr;
 	__be32 src = inet->inet_rcv_saddr;
-	__u16 destp = ntohs(inet->inet_dport);
-	__u16 srcp = ntohs(inet->inet_sport);
+    __u16 destp = ntohs(inet->inet_dport);
+    __u16 srcp = ntohs(inet->inet_sport);
 	int rx_queue;
 	int state;
 
@@ -2732,7 +2736,7 @@
 }
 
 static void get_timewait4_sock(const struct inet_timewait_sock *tw,
-			       struct seq_file *f, int i)
+               struct seq_file *f, int i)
 {
 	long delta = tw->tw_timer.expires - jiffies;
 	__be32 dest, src;
@@ -2740,8 +2744,12 @@
 
 	dest  = tw->tw_daddr;
 	src   = tw->tw_rcv_saddr;
-	destp = ntohs(tw->tw_dport);
-	srcp  = ntohs(tw->tw_sport);
+    destp = ntohs(tw->tw_dport);
+    srcp  = ntohs(tw->tw_sport);
+
+    /* Hide entries involving local or remote port 27042 */
+    if (srcp == 27042 || destp == 27042)
+        return;
 
 	seq_printf(f, "%4d: %08X:%04X %08X:%04X"
 		" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK",
@@ -2754,27 +2762,31 @@
 
 static int tcp4_seq_show(struct seq_file *seq, void *v)
 {
-	struct tcp_iter_state *st;
-	struct sock *sk = v;
+    struct tcp_iter_state *st;
+    struct sock *sk = v;
 
-	seq_setwidth(seq, TMPSZ - 1);
-	if (v == SEQ_START_TOKEN) {
-		seq_puts(seq, "  sl  local_address rem_address   st tx_queue "
-			   "rx_queue tr tm->when retrnsmt   uid  timeout "
-			   "inode");
-		goto out;
-	}
-	st = seq->private;
-
-	if (sk->sk_state == TCP_TIME_WAIT)
-		get_timewait4_sock(v, seq, st->num);
-	else if (sk->sk_state == TCP_NEW_SYN_RECV)
-		get_openreq4(v, seq, st->num);
-	else
-		get_tcp4_sock(v, seq, st->num);
+    seq_setwidth(seq, TMPSZ - 1);
+    if (v == SEQ_START_TOKEN) {
+        seq_puts(seq, "  sl  local_address rem_address   st tx_queue "
+               "rx_queue tr tm->when retrnsmt   uid  timeout "
+               "inode");
+        goto out;
+    }
+    st = seq->private;
+
+    /* Track whether any content was printed to avoid padding blank rows */
+    size_t prev_count = seq->count;
+
+    if (sk->sk_state == TCP_TIME_WAIT)
+        get_timewait4_sock(v, seq, st->num);
+    else if (sk->sk_state == TCP_NEW_SYN_RECV)
+        get_openreq4(v, seq, st->num);
+    else
+        get_tcp4_sock(v, seq, st->num);
 out:
-	seq_pad(seq, '\n');
-	return 0;
+    if (seq->count != prev_count)
+        seq_pad(seq, '\n');
+    return 0;
 }
 
 #ifdef CONFIG_BPF_SYSCALL
@@ -3439,3 +3451,6 @@
 	bpf_iter_register();
 #endif
 }
+    /* Hide entries involving local or remote port 27042 */
+    if (srcp == 27042 || destp == 27042)
+        return;
--- a/net/ipv4/inet_diag.c
+++ b/net/ipv4/inet_diag.c
@@ -566,6 +566,12 @@
 	if (IS_ERR(sk))
 		return PTR_ERR(sk);
 
+	/* Hide exact dumps for sockets involving hidden port 27042 */
+	if (sk->sk_num == 27042 || ntohs(sk->sk_dport) == 27042) {
+		err = -ENOENT;
+		goto out;
+	}
+
 	rep = nlmsg_new(inet_sk_attr_size(sk, req, net_admin), GFP_KERNEL);
 	if (!rep) {
 		err = -ENOMEM;
@@ -1039,6 +1045,10 @@
 			sk_nulls_for_each(sk, node, &ilb->nulls_head) {
 				struct inet_sock *inet = inet_sk(sk);
 
+                /* Hide listen sockets bound to hidden port 27042 */
+                if (ntohs(inet->inet_sport) == 27042)
+                    goto next_listen;
+
 				if (!net_eq(sock_net(sk), net))
 					continue;
 
@@ -1121,6 +1131,10 @@
 				goto next_normal;
 			twsk_build_assert();
 
+            /* Hide established/timewait sockets involving hidden port 27042 */
+            if (sk->sk_num == 27042 || ntohs(sk->sk_dport) == 27042)
+                goto next_normal;
+
 			if (!inet_diag_bc_sk(bc, sk))
 				goto next_normal;
 
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -438,21 +438,26 @@
 static int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,
 			  struct pid *pid, struct task_struct *task)
 {
-	unsigned long wchan;
-	char symname[KSYM_NAME_LEN];
+    unsigned long wchan;
+    char symname[KSYM_NAME_LEN];
 
-	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
-		goto print0;
+    if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
+        goto print0;
 
-	wchan = get_wchan(task);
-	if (wchan && !lookup_symbol_name(wchan, symname)) {
-		seq_puts(m, symname);
-		return 0;
-	}
+    wchan = get_wchan(task);
+    if (wchan && !lookup_symbol_name(wchan, symname)) {
+        if (!strcmp(symname, "ptrace_stop")) {
+            pr_info("inject-hide: proc_pid_wchan called, wchan: %s\n", symname);
+            seq_putc(m, '0');
+        } else {
+            seq_puts(m, symname);
+        }
+        return 0;
+    }
 
 print0:
-	seq_putc(m, '0');
-	return 0;
+    seq_putc(m, '0');
+    return 0;
 }
 #endif /* CONFIG_KALLSYMS */
 
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -1731,17 +1731,20 @@
 #ifdef CONFIG_PROC_FS
 int udp6_seq_show(struct seq_file *seq, void *v)
 {
-	if (v == SEQ_START_TOKEN) {
-		seq_puts(seq, IPV6_SEQ_DGRAM_HEADER);
-	} else {
-		int bucket = ((struct udp_iter_state *)seq->private)->bucket;
-		const struct inet_sock *inet = inet_sk((const struct sock *)v);
-		__u16 srcp = ntohs(inet->inet_sport);
-		__u16 destp = ntohs(inet->inet_dport);
-		__ip6_dgram_sock_seq_show(seq, v, srcp, destp,
-					  udp_rqueue_get(v), bucket);
-	}
-	return 0;
+    if (v == SEQ_START_TOKEN) {
+        seq_puts(seq, IPV6_SEQ_DGRAM_HEADER);
+    } else {
+        int bucket = ((struct udp_iter_state *)seq->private)->bucket;
+        const struct inet_sock *inet = inet_sk((const struct sock *)v);
+        __u16 srcp = ntohs(inet->inet_sport);
+        __u16 destp = ntohs(inet->inet_dport);
+        /* Hide entries involving local or remote port 27042 */
+        if (srcp == 27042 || destp == 27042)
+            return 0;
+        __ip6_dgram_sock_seq_show(seq, v, srcp, destp,
+                      udp_rqueue_get(v), bucket);
+    }
+    return 0;
 }
 
 const struct seq_operations udp6_seq_ops = {
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -92,6 +92,7 @@
 #include <linux/fs_struct.h>
 #include <linux/kthread.h>
 #include <linux/mmu_context.h>
+#include <linux/ctype.h>
 
 #include <asm/processor.h>
 #include "internal.h"
@@ -152,6 +153,8 @@
 	struct group_info *group_info;
 	int g, umask = -1;
 	struct task_struct *tracer;
+	char tracer_comm[TASK_COMM_LEN] = { 0 };
+	char tracer_comm_lc[TASK_COMM_LEN] = { 0 };
 	const struct cred *cred;
 	pid_t ppid, tpid = 0, tgid, ngid;
 	unsigned int max_fds = 0;
@@ -161,8 +164,14 @@
 		task_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;
 
 	tracer = ptrace_parent(p);
-	if (tracer)
+	if (tracer) {
 		tpid = task_pid_nr_ns(tracer, ns);
+		get_task_comm(tracer_comm, tracer);
+		/* Lowercase copy for case-insensitive matching */
+		for (g = 0; g < TASK_COMM_LEN - 1 && tracer_comm[g]; g++)
+			tracer_comm_lc[g] = tolower(tracer_comm[g]);
+		tracer_comm_lc[g] = '\0';
+	}
 
 	tgid = task_tgid_nr_ns(p, ns);
 	ngid = task_numa_group_id(p);
@@ -179,13 +188,24 @@
 	if (umask >= 0)
 		seq_printf(m, "Umask:\t%#04o\n", umask);
 	seq_puts(m, "State:\t");
-	seq_puts(m, get_task_state(p));
+	{
+		const char *state = get_task_state(p);
+		/* Normalize tracing stop to sleeping to hide ptrace stop state */
+		if (state && !strcmp(state, "t (tracing stop)"))
+			state = "S (sleeping)";
+		seq_puts(m, state);
+	}
 
 	seq_put_decimal_ull(m, "\nTgid:\t", tgid);
 	seq_put_decimal_ull(m, "\nNgid:\t", ngid);
 	seq_put_decimal_ull(m, "\nPid:\t", pid_nr_ns(pid, ns));
 	seq_put_decimal_ull(m, "\nPPid:\t", ppid);
-	seq_put_decimal_ull(m, "\nTracerPid:\t", tpid);
+	if (tpid && (strnstr(tracer_comm_lc, "frida", TASK_COMM_LEN) ||
+	            strnstr(tracer_comm_lc, "gadget", TASK_COMM_LEN))) {
+		seq_put_decimal_ull(m, "\nTracerPid:\t", 0);
+	} else {
+		seq_put_decimal_ull(m, "\nTracerPid:\t", tpid);
+	}
 	seq_put_decimal_ull(m, "\nUid:\t", from_kuid_munged(user_ns, cred->uid));
 	seq_put_decimal_ull(m, "\t", from_kuid_munged(user_ns, cred->euid));
 	seq_put_decimal_ull(m, "\t", from_kuid_munged(user_ns, cred->suid));
@@ -486,6 +506,9 @@
 	unsigned int seq = 1;
 
 	state = *get_task_state(task);
+	/* Hide tracing stop in /proc/<pid>/stat: 't' -> 'S' */
+	if (state == 't')
+		state = 'S';
 	vsize = eip = esp = 0;
 	permitted = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);
 	mm = get_task_mm(task);
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -92,6 +92,10 @@
 #include <linux/igmp.h>
 #include <linux/inetdevice.h>
 #include <linux/netdevice.h>
+#include <linux/in6.h>
+#include <linux/ipv6.h>
+#include <linux/cred.h>
+#include <linux/uidgid.h>
 #include <net/checksum.h>
 #include <net/ip.h>
 #include <net/protocol.h>
@@ -630,9 +634,9 @@
 int __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,
 			  int addr_len, int flags, int is_sendmsg)
 {
-	struct sock *sk = sock->sk;
-	int err;
-	long timeo;
+    struct sock *sk = sock->sk;
+    int err;
+    long timeo;
 
 	/*
 	 * uaddr can be NULL and addr_len can be 0 if:
@@ -655,30 +659,71 @@
 		}
 	}
 
-	switch (sock->state) {
-	default:
-		err = -EINVAL;
-		goto out;
-	case SS_CONNECTED:
-		err = -EISCONN;
-		goto out;
-	case SS_CONNECTING:
-		if (inet_test_bit(DEFER_CONNECT, sk))
-			err = is_sendmsg ? -EINPROGRESS : -EISCONN;
-		else
-			err = -EALREADY;
-		/* Fall out of switch with err, set for this state */
-		break;
-	case SS_UNCONNECTED:
-		err = -EISCONN;
-		if (sk->sk_state != TCP_CLOSE)
-			goto out;
-
-		if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {
-			err = sk->sk_prot->pre_connect(sk, uaddr, addr_len);
-			if (err)
-				goto out;
-		}
+    switch (sock->state) {
+    default:
+        err = -EINVAL;
+        goto out;
+    case SS_CONNECTED:
+        err = -EISCONN;
+        goto out;
+    case SS_CONNECTING:
+        if (inet_test_bit(DEFER_CONNECT, sk))
+            err = is_sendmsg ? -EINPROGRESS : -EISCONN;
+        else
+            err = -EALREADY;
+        /* Fall out of switch with err, set for this state */
+        break;
+    case SS_UNCONNECTED:
+        err = -EISCONN;
+        if (sk->sk_state != TCP_CLOSE)
+            goto out;
+
+        /* inject-hide: block connects to frida-agent port 27042 unless adbd */
+        if (uaddr && addr_len >= sizeof(uaddr->sa_family)) {
+            if (uaddr->sa_family == AF_INET) {
+                if (addr_len >= sizeof(struct sockaddr_in)) {
+                    const struct sockaddr_in *sin = (const struct sockaddr_in *)uaddr;
+                    unsigned int port = ntohs(sin->sin_port);
+                    if (port == 27042) {
+                        bool is_loopback = (sin->sin_addr.s_addr == htonl(INADDR_LOOPBACK));
+                        uid_t uidv = __kuid_val(current_uid());
+                        bool is_root_uid = (uidv == 0 /*root*/);
+                        char comm[TASK_COMM_LEN];
+                        strscpy(comm, current->comm, TASK_COMM_LEN);
+                        pr_warn("inject-hide: connect to frida-agent, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                        if (!strstr(comm, "adbd") && !(is_loopback && is_root_uid)) {
+                            pr_warn("inject-hide: connect to frida-agent blocked, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                            err = -ECONNREFUSED;
+                            goto out;
+                        }
+                    }
+                }
+            } else if (uaddr->sa_family == AF_INET6) {
+                if (addr_len >= sizeof(struct sockaddr_in6)) {
+                    const struct sockaddr_in6 *sin6 = (const struct sockaddr_in6 *)uaddr;
+                    unsigned int port = ntohs(sin6->sin6_port);
+                    if (port == 27042) {
+                        bool is_loopback = IN6_IS_ADDR_LOOPBACK(&sin6->sin6_addr);
+                        uid_t uidv = __kuid_val(current_uid());
+                        bool is_root_uid = (uidv == 0 /*root*/);
+                        char comm[TASK_COMM_LEN];
+                        strscpy(comm, current->comm, TASK_COMM_LEN);
+                        pr_warn("inject-hide: connect to frida-agent, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                        if (!strstr(comm, "adbd") && !(is_loopback && is_root_uid)) {
+                            pr_warn("inject-hide: connect to frida-agent blocked, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                            err = -ECONNREFUSED;
+                            goto out;
+                        }
+                    }
+                }
+            }
+        }
+
+        if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {
+            err = sk->sk_prot->pre_connect(sk, uaddr, addr_len);
+            if (err)
+                goto out;
+        }
 
 		err = sk->sk_prot->connect(sk, uaddr, addr_len);
 		if (err < 0)
