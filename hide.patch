--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -27,6 +27,50 @@
 #include <linux/susfs_def.h>
 #endif
 
+#include <linux/string.h> // for strstr
+
+// SUSFS extension: Keyword matcher for additional hiding
+#define SUSFS_HIDE_KW_MAX 12
+static const char *susfs_hide_keywords[SUSFS_HIDE_KW_MAX] = {
+    "frida-agent", "frida-server", "gadget", "jit-cache",
+    "gum-js-loop", "GumJS", "gmain", "/data/local/tmp",
+    "frida", "gum-js", "linjector", "gdbus"
+};
+
+static int susfs_should_hide_name(const char *name) {
+     int i;
+     if (!name) return 0;
+     for (i = 0; i < SUSFS_HIDE_KW_MAX; i++) {
+         if (strstr(name, susfs_hide_keywords[i])) return 1;
+     }
+     return 0;
+ }
+
+static int susfs_should_hide_vma(struct vm_area_struct *vma) {
+    struct mm_struct *mm = vma->vm_mm;
+    struct file *file = vma->vm_file;
+    struct anon_vma_name *anon_name = NULL;
+    const char *name = NULL;
+
+    if (file && file->f_path.dentry) {
+        const char *dname = file->f_path.dentry->d_name.name;
+        if (susfs_should_hide_name(dname)) return 1;
+    }
+
+    if (mm) anon_name = anon_vma_name(vma);
+    if (anon_name && susfs_should_hide_name(anon_name->name)) return 1;
+
+    if (vma->vm_ops && vma->vm_ops->name) {
+        name = vma->vm_ops->name(vma);
+        if (name && susfs_should_hide_name(name)) return 1;
+    }
+
+    name = arch_vma_name(vma);
+    if (name && susfs_should_hide_name(name)) return 1;
+
+    return 0;
+}
+
 #include <asm/elf.h>
 #include <asm/tlb.h>
 #include <asm/tlbflush.h>
@@ -300,6 +344,26 @@
 			goto done;
 		}
 #endif
+		// Layered SUSFS extension: Additional keyword-based hiding, gated by policy
+		if (susfs_is_current_proc_umounted() && file && file->f_path.dentry) {
+			const char *dname = file->f_path.dentry->d_name.name;
+			if (susfs_should_hide_name(dname)) {
+				seq_setwidth(m, 25 + sizeof(void *) * 6 - 1);
+				seq_put_hex_ll(m, NULL, vma->vm_start, 8);
+				seq_put_hex_ll(m, "-", vma->vm_end, 8);
+				seq_putc(m, ' ');
+				seq_putc(m, '-');
+				seq_putc(m, '-');
+				seq_putc(m, '-');
+				seq_putc(m, 'p');
+				seq_put_hex_ll(m, " ", pgoff, 8);
+				seq_put_hex_ll(m, " ", MAJOR(dev), 2);
+				seq_put_hex_ll(m, ":", MINOR(dev), 2);
+				seq_put_decimal_ull(m, " ", ino);
+				seq_putc(m, ' ');
+				goto done;
+			}
+		}
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
 		if (unlikely(inode->i_mapping->flags & BIT_SUS_KSTAT)) {
 			susfs_sus_ino_for_show_map_vma(inode->i_ino, &dev, &ino);
@@ -340,10 +404,26 @@
 		goto done;
 	}
 
+	// Layered SUSFS extension: Suppress suspicious anon labels if gated
+	if (susfs_is_current_proc_umounted()) {
+		if (anon_name && susfs_should_hide_name(anon_name->name)) {
+			seq_pad(m, ' ');
+			seq_puts(m, "[anon]");
+			goto done;
+		}
+	}
+
 	if (vma->vm_ops && vma->vm_ops->name) {
 		name = vma->vm_ops->name(vma);
-		if (name)
+		if (name) {
+			// Layered SUSFS extension: Suppress suspicious vm_ops labels if gated
+			if (susfs_is_current_proc_umounted() && susfs_should_hide_name(name)) {
+				seq_pad(m, ' ');
+				seq_puts(m, "[vmops]");
+				goto done;
+			}
 			goto done;
+		}
 	}
 
 	name = arch_vma_name(vma);
@@ -1018,6 +1098,11 @@
 			goto bypass_orig_flow;
 		}
 #endif
+		// Layered SUSFS extension: Keyword-based hiding for smaps_rollup consistency
+		if (susfs_is_current_proc_umounted() && susfs_should_hide_vma(vma)) {
+			memset(&mss, 0, sizeof(mss));
+			goto bypass_orig_flow;
+		}
 
 		smap_gather_stats(vma, &mss, 0);
 #ifdef CONFIG_KSU_SUSFS_SUS_MAP
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -438,21 +438,26 @@
 static int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,
 			  struct pid *pid, struct task_struct *task)
 {
-	unsigned long wchan;
-	char symname[KSYM_NAME_LEN];
+    unsigned long wchan;
+    char symname[KSYM_NAME_LEN];
 
-	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
-		goto print0;
+    if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
+        goto print0;
 
-	wchan = get_wchan(task);
-	if (wchan && !lookup_symbol_name(wchan, symname)) {
-		seq_puts(m, symname);
-		return 0;
-	}
+    wchan = get_wchan(task);
+    if (wchan && !lookup_symbol_name(wchan, symname)) {
+        if (!strcmp(symname, "ptrace_stop")) {
+            pr_info("inject-hide: proc_pid_wchan called, wchan: %s\n", symname);
+            seq_putc(m, '0');
+        } else {
+            seq_puts(m, symname);
+        }
+        return 0;
+    }
 
 print0:
-	seq_putc(m, '0');
-	return 0;
+    seq_putc(m, '0');
+    return 0;
 }
 #endif /* CONFIG_KALLSYMS */
 
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -92,6 +92,7 @@
 #include <linux/fs_struct.h>
 #include <linux/kthread.h>
 #include <linux/mmu_context.h>
+#include <linux/ctype.h>
 
 #include <asm/processor.h>
 #include "internal.h"
@@ -152,6 +153,8 @@
 	struct group_info *group_info;
 	int g, umask = -1;
 	struct task_struct *tracer;
+	char tracer_comm[TASK_COMM_LEN] = { 0 };
+	char tracer_comm_lc[TASK_COMM_LEN] = { 0 };
 	const struct cred *cred;
 	pid_t ppid, tpid = 0, tgid, ngid;
 	unsigned int max_fds = 0;
@@ -161,8 +164,14 @@
 		task_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;
 
 	tracer = ptrace_parent(p);
-	if (tracer)
+	if (tracer) {
 		tpid = task_pid_nr_ns(tracer, ns);
+		get_task_comm(tracer_comm, tracer);
+		/* Lowercase copy for case-insensitive matching */
+		for (g = 0; g < TASK_COMM_LEN - 1 && tracer_comm[g]; g++)
+			tracer_comm_lc[g] = tolower(tracer_comm[g]);
+		tracer_comm_lc[g] = '\0';
+	}
 
 	tgid = task_tgid_nr_ns(p, ns);
 	ngid = task_numa_group_id(p);
@@ -179,13 +188,24 @@
 	if (umask >= 0)
 		seq_printf(m, "Umask:\t%#04o\n", umask);
 	seq_puts(m, "State:\t");
-	seq_puts(m, get_task_state(p));
+	{
+		const char *state = get_task_state(p);
+		/* Normalize tracing stop to sleeping to hide ptrace stop state */
+		if (state && !strcmp(state, "t (tracing stop)"))
+			state = "S (sleeping)";
+		seq_puts(m, state);
+	}
 
 	seq_put_decimal_ull(m, "\nTgid:\t", tgid);
 	seq_put_decimal_ull(m, "\nNgid:\t", ngid);
 	seq_put_decimal_ull(m, "\nPid:\t", pid_nr_ns(pid, ns));
 	seq_put_decimal_ull(m, "\nPPid:\t", ppid);
-	seq_put_decimal_ull(m, "\nTracerPid:\t", tpid);
+	if (tpid && (strnstr(tracer_comm_lc, "frida", TASK_COMM_LEN) ||
+	            strnstr(tracer_comm_lc, "gadget", TASK_COMM_LEN))) {
+		seq_put_decimal_ull(m, "\nTracerPid:\t", 0);
+	} else {
+		seq_put_decimal_ull(m, "\nTracerPid:\t", tpid);
+	}
 	seq_put_decimal_ull(m, "\nUid:\t", from_kuid_munged(user_ns, cred->uid));
 	seq_put_decimal_ull(m, "\t", from_kuid_munged(user_ns, cred->euid));
 	seq_put_decimal_ull(m, "\t", from_kuid_munged(user_ns, cred->suid));
@@ -486,6 +506,9 @@
 	unsigned int seq = 1;
 
 	state = *get_task_state(task);
+	/* Hide tracing stop in /proc/<pid>/stat: 't' -> 'S' */
+	if (state == 't')
+		state = 'S';
 	vsize = eip = esp = 0;
 	permitted = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);
 	mm = get_task_mm(task);
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -92,6 +92,10 @@
 #include <linux/igmp.h>
 #include <linux/inetdevice.h>
 #include <linux/netdevice.h>
+#include <linux/in6.h>
+#include <linux/ipv6.h>
+#include <linux/cred.h>
+#include <linux/uidgid.h>
 #include <net/checksum.h>
 #include <net/ip.h>
 #include <net/protocol.h>
@@ -630,9 +634,9 @@
 int __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,
 			  int addr_len, int flags, int is_sendmsg)
 {
-	struct sock *sk = sock->sk;
-	int err;
-	long timeo;
+    struct sock *sk = sock->sk;
+    int err;
+    long timeo;
 
 	/*
 	 * uaddr can be NULL and addr_len can be 0 if:
@@ -655,30 +659,71 @@
 		}
 	}
 
-	switch (sock->state) {
-	default:
-		err = -EINVAL;
-		goto out;
-	case SS_CONNECTED:
-		err = -EISCONN;
-		goto out;
-	case SS_CONNECTING:
-		if (inet_test_bit(DEFER_CONNECT, sk))
-			err = is_sendmsg ? -EINPROGRESS : -EISCONN;
-		else
-			err = -EALREADY;
-		/* Fall out of switch with err, set for this state */
-		break;
-	case SS_UNCONNECTED:
-		err = -EISCONN;
-		if (sk->sk_state != TCP_CLOSE)
-			goto out;
-
-		if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {
-			err = sk->sk_prot->pre_connect(sk, uaddr, addr_len);
-			if (err)
-				goto out;
-		}
+    switch (sock->state) {
+    default:
+        err = -EINVAL;
+        goto out;
+    case SS_CONNECTED:
+        err = -EISCONN;
+        goto out;
+    case SS_CONNECTING:
+        if (inet_test_bit(DEFER_CONNECT, sk))
+            err = is_sendmsg ? -EINPROGRESS : -EISCONN;
+        else
+            err = -EALREADY;
+        /* Fall out of switch with err, set for this state */
+        break;
+    case SS_UNCONNECTED:
+        err = -EISCONN;
+        if (sk->sk_state != TCP_CLOSE)
+            goto out;
+
+        /* inject-hide: block connects to frida-agent port 27042 unless adbd */
+        if (uaddr && addr_len >= sizeof(uaddr->sa_family)) {
+            if (uaddr->sa_family == AF_INET) {
+                if (addr_len >= sizeof(struct sockaddr_in)) {
+                    const struct sockaddr_in *sin = (const struct sockaddr_in *)uaddr;
+                    unsigned int port = ntohs(sin->sin_port);
+                    if (port == 27042) {
+                        bool is_loopback = (sin->sin_addr.s_addr == htonl(INADDR_LOOPBACK));
+                        uid_t uidv = __kuid_val(current_uid());
+                        bool is_root_uid = (uidv == 0 /*root*/);
+                        char comm[TASK_COMM_LEN];
+                        strscpy(comm, current->comm, TASK_COMM_LEN);
+                        pr_warn("inject-hide: connect to frida-agent, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                        if (!strstr(comm, "adbd") && !(is_loopback && is_root_uid)) {
+                            pr_warn("inject-hide: connect to frida-agent blocked, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                            err = -ECONNREFUSED;
+                            goto out;
+                        }
+                    }
+                }
+            } else if (uaddr->sa_family == AF_INET6) {
+                if (addr_len >= sizeof(struct sockaddr_in6)) {
+                    const struct sockaddr_in6 *sin6 = (const struct sockaddr_in6 *)uaddr;
+                    unsigned int port = ntohs(sin6->sin6_port);
+                    if (port == 27042) {
+                        bool is_loopback = ipv6_addr_loopback(&sin6->sin6_addr);
+                        uid_t uidv = __kuid_val(current_uid());
+                        bool is_root_uid = (uidv == 0 /*root*/);
+                        char comm[TASK_COMM_LEN];
+                        strscpy(comm, current->comm, TASK_COMM_LEN);
+                        pr_warn("inject-hide: connect to frida-agent, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                        if (!strstr(comm, "adbd") && !(is_loopback && is_root_uid)) {
+                            pr_warn("inject-hide: connect to frida-agent blocked, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                            err = -ECONNREFUSED;
+                            goto out;
+                        }
+                    }
+                }
+            }
+        }
+
+        if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {
+            err = sk->sk_prot->pre_connect(sk, uaddr, addr_len);
+            if (err)
+                goto out;
+        }
 
 		err = sk->sk_prot->connect(sk, uaddr, addr_len);
 		if (err < 0)
