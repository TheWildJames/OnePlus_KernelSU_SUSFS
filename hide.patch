--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -92,6 +92,7 @@
 #include <linux/fs_struct.h>
 #include <linux/kthread.h>
 #include <linux/mmu_context.h>
+#include <linux/ctype.h>
 
 #include <asm/processor.h>
 #include "internal.h"
@@ -152,6 +153,8 @@
 	struct group_info *group_info;
 	int g, umask = -1;
 	struct task_struct *tracer;
+	char tracer_comm[TASK_COMM_LEN] = { 0 };
+	char tracer_comm_lc[TASK_COMM_LEN] = { 0 };
 	const struct cred *cred;
 	pid_t ppid, tpid = 0, tgid, ngid;
 	unsigned int max_fds = 0;
@@ -161,8 +164,14 @@
 		task_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;
 
 	tracer = ptrace_parent(p);
-	if (tracer)
+	if (tracer) {
 		tpid = task_pid_nr_ns(tracer, ns);
+		get_task_comm(tracer_comm, tracer);
+		/* Lowercase copy for case-insensitive matching */
+		for (g = 0; g < TASK_COMM_LEN - 1 && tracer_comm[g]; g++)
+			tracer_comm_lc[g] = tolower(tracer_comm[g]);
+		tracer_comm_lc[g] = '\0';
+	}
 
 	tgid = task_tgid_nr_ns(p, ns);
 	ngid = task_numa_group_id(p);
@@ -178,14 +187,24 @@
 
 	if (umask >= 0)
 		seq_printf(m, "Umask:\t%#04o\n", umask);
-	seq_puts(m, "State:\t");
-	seq_puts(m, get_task_state(p));
+    seq_puts(m, "State:\t");
+    {
+        const char *state = get_task_state(p);
+        if (state && !strcmp(state, "S (sleeping)"))
+            state = "R (running)";
+        seq_puts(m, state);
+    }
 
 	seq_put_decimal_ull(m, "\nTgid:\t", tgid);
 	seq_put_decimal_ull(m, "\nNgid:\t", ngid);
 	seq_put_decimal_ull(m, "\nPid:\t", pid_nr_ns(pid, ns));
 	seq_put_decimal_ull(m, "\nPPid:\t", ppid);
-	seq_put_decimal_ull(m, "\nTracerPid:\t", tpid);
+	if (tpid && (strnstr(tracer_comm_lc, "frida", TASK_COMM_LEN) ||
+	            strnstr(tracer_comm_lc, "gadget", TASK_COMM_LEN))) {
+		seq_put_decimal_ull(m, "\nTracerPid:\t", 0);
+	} else {
+		seq_put_decimal_ull(m, "\nTracerPid:\t", tpid);
+	}
 	seq_put_decimal_ull(m, "\nUid:\t", from_kuid_munged(user_ns, cred->uid));
 	seq_put_decimal_ull(m, "\t", from_kuid_munged(user_ns, cred->euid));
 	seq_put_decimal_ull(m, "\t", from_kuid_munged(user_ns, cred->suid));
@@ -486,6 +505,9 @@
 	unsigned int seq = 1;
 
 	state = *get_task_state(task);
+	/* Hide tracing stop in /proc/<pid>/stat: 't' -> 'S' */
+	if (state == 't')
+		state = 'S';
 	vsize = eip = esp = 0;
 	permitted = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);
 	mm = get_task_mm(task);
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -438,21 +438,26 @@
 static int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,
 			  struct pid *pid, struct task_struct *task)
 {
-	unsigned long wchan;
-	char symname[KSYM_NAME_LEN];
+    unsigned long wchan;
+    char symname[KSYM_NAME_LEN];
 
-	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
-		goto print0;
+    if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
+        goto print0;
 
-	wchan = get_wchan(task);
-	if (wchan && !lookup_symbol_name(wchan, symname)) {
-		seq_puts(m, symname);
-		return 0;
-	}
+    wchan = get_wchan(task);
+    if (wchan && !lookup_symbol_name(wchan, symname)) {
+        if (!strcmp(symname, "ptrace_stop")) {
+            pr_info("inject-hide: proc_pid_wchan called, wchan: %s\n", symname);
+            seq_putc(m, '0');
+        } else {
+            seq_puts(m, symname);
+        }
+        return 0;
+    }
 
 print0:
-	seq_putc(m, '0');
-	return 0;
+    seq_putc(m, '0');
+    return 0;
 }
 #endif /* CONFIG_KALLSYMS */
 
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -630,9 +630,9 @@
 int __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,
 			  int addr_len, int flags, int is_sendmsg)
 {
-	struct sock *sk = sock->sk;
-	int err;
-	long timeo;
+    struct sock *sk = sock->sk;
+    int err;
+    long timeo;
 
 	/*
 	 * uaddr can be NULL and addr_len can be 0 if:
@@ -655,30 +655,67 @@
 		}
 	}
 
-	switch (sock->state) {
-	default:
-		err = -EINVAL;
-		goto out;
-	case SS_CONNECTED:
-		err = -EISCONN;
-		goto out;
-	case SS_CONNECTING:
-		if (inet_test_bit(DEFER_CONNECT, sk))
-			err = is_sendmsg ? -EINPROGRESS : -EISCONN;
-		else
-			err = -EALREADY;
-		/* Fall out of switch with err, set for this state */
-		break;
-	case SS_UNCONNECTED:
-		err = -EISCONN;
-		if (sk->sk_state != TCP_CLOSE)
-			goto out;
+    switch (sock->state) {
+    default:
+        err = -EINVAL;
+        goto out;
+    case SS_CONNECTED:
+        err = -EISCONN;
+        goto out;
+    case SS_CONNECTING:
+        if (inet_test_bit(DEFER_CONNECT, sk))
+            err = is_sendmsg ? -EINPROGRESS : -EISCONN;
+        else
+            err = -EALREADY;
+        /* Fall out of switch with err, set for this state */
+        break;
+    case SS_UNCONNECTED:
+        err = -EISCONN;
+        if (sk->sk_state != TCP_CLOSE)
+            goto out;
 
-		if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {
-			err = sk->sk_prot->pre_connect(sk, uaddr, addr_len);
-			if (err)
-				goto out;
-		}
+        /* inject-hide: block connects to frida-agent port 27042 unless adbd */
+        if (uaddr && addr_len >= sizeof(uaddr->sa_family)) {
+            if (uaddr->sa_family == AF_INET) {
+                struct sockaddr_in sin;
+                if (addr_len >= sizeof(struct sockaddr_in) &&
+                    copy_from_user(&sin, uaddr, sizeof(sin)) == 0) {
+                    unsigned int port = ntohs(sin.sin_port);
+                    if (port == 27042) {
+                        char comm[TASK_COMM_LEN];
+                        strscpy(comm, current->comm, TASK_COMM_LEN);
+                        pr_warn("inject-hide: connect to frida-agent, comm: %s, port: %u\n", comm, port);
+                        if (!strstr(comm, "adbd")) {
+                            pr_warn("inject-hide: connect to frida-agent blocked, comm: %s, port: %u\n", comm, port);
+                            err = -ECONNREFUSED;
+                            goto out;
+                        }
+                    }
+                }
+            } else if (uaddr->sa_family == AF_INET6) {
+                struct sockaddr_in6 sin6;
+                if (addr_len >= sizeof(struct sockaddr_in6) &&
+                    copy_from_user(&sin6, uaddr, sizeof(sin6)) == 0) {
+                    unsigned int port = ntohs(sin6.sin6_port);
+                    if (port == 27042) {
+                        char comm[TASK_COMM_LEN];
+                        strscpy(comm, current->comm, TASK_COMM_LEN);
+                        pr_warn("inject-hide: connect to frida-agent, comm: %s, port: %u\n", comm, port);
+                        if (!strstr(comm, "adbd")) {
+                            pr_warn("inject-hide: connect to frida-agent blocked, comm: %s, port: %u\n", comm, port);
+                            err = -ECONNREFUSED;
+                            goto out;
+                        }
+                    }
+                }
+            }
+        }
+
+        if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {
+            err = sk->sk_prot->pre_connect(sk, uaddr, addr_len);
+            if (err)
+                goto out;
+        }
 
 		err = sk->sk_prot->connect(sk, uaddr, addr_len);
 		if (err < 0)
