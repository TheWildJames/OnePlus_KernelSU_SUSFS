--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -6,6 +6,7 @@
 #include <linux/mount.h>
 #include <linux/ksm.h>
 #include <linux/seq_file.h>
+#include <linux/string.h>
 #include <linux/highmem.h>
 #include <linux/ptrace.h>
 #include <linux/slab.h>
@@ -263,6 +264,29 @@
 	seq_putc(m, ' ');
 }
 
+#define SUSFS_HIDE_KW_MAX 6
+static bool susfs_should_hide_name(const char *s)
+{
+    static const char *keywords[SUSFS_HIDE_KW_MAX + 1] = {
+        "frida-agent",
+        "frida",
+        "gadget",
+        "gum-js-loop",
+        "GumJS",
+        "gmain",
+        NULL,
+    };
+
+    if (!s)
+        return false;
+
+    for (int i = 0; keywords[i] != NULL; ++i) {
+        if (strstr(s, keywords[i]))
+            return true;
+    }
+    return false;
+}
+
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
 extern void susfs_sus_ino_for_show_map_vma(unsigned long ino, dev_t *out_dev, unsigned long *out_ino);
 #endif
@@ -333,10 +357,19 @@
 		 * If user named this anon shared memory via
 		 * prctl(PR_SET_VMA ..., use the provided name.
 		 */
-		if (anon_name)
-			seq_printf(m, "[anon_shmem:%s]", anon_name->name);
-		else
-			seq_file_path(m, file, "\n");
+		if (anon_name) {
+			if (susfs_should_hide_name(anon_name->name))
+				seq_puts(m, "[anon_shmem]");
+			else
+				seq_printf(m, "[anon_shmem:%s]", anon_name->name);
+		} else {
+			const char *dname = file->f_path.dentry ? file->f_path.dentry->d_name.name : NULL;
+			if (dname && susfs_should_hide_name(dname)) {
+				/* suppress filename output to avoid exposing sensitive names */
+			} else {
+				seq_file_path(m, file, "\n");
+			}
+		}
 		goto done;
 	}
 
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -438,21 +438,26 @@
 static int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,
 			  struct pid *pid, struct task_struct *task)
 {
-	unsigned long wchan;
-	char symname[KSYM_NAME_LEN];
+    unsigned long wchan;
+    char symname[KSYM_NAME_LEN];
 
-	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
-		goto print0;
+    if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
+        goto print0;
 
-	wchan = get_wchan(task);
-	if (wchan && !lookup_symbol_name(wchan, symname)) {
-		seq_puts(m, symname);
-		return 0;
-	}
+    wchan = get_wchan(task);
+    if (wchan && !lookup_symbol_name(wchan, symname)) {
+        if (!strcmp(symname, "ptrace_stop")) {
+            pr_info("inject-hide: proc_pid_wchan called, wchan: %s\n", symname);
+            seq_putc(m, '0');
+        } else {
+            seq_puts(m, symname);
+        }
+        return 0;
+    }
 
 print0:
-	seq_putc(m, '0');
-	return 0;
+    seq_putc(m, '0');
+    return 0;
 }
 #endif /* CONFIG_KALLSYMS */
 
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -92,6 +92,7 @@
 #include <linux/fs_struct.h>
 #include <linux/kthread.h>
 #include <linux/mmu_context.h>
+#include <linux/ctype.h>
 
 #include <asm/processor.h>
 #include "internal.h"
@@ -152,6 +153,8 @@
 	struct group_info *group_info;
 	int g, umask = -1;
 	struct task_struct *tracer;
+	char tracer_comm[TASK_COMM_LEN] = { 0 };
+	char tracer_comm_lc[TASK_COMM_LEN] = { 0 };
 	const struct cred *cred;
 	pid_t ppid, tpid = 0, tgid, ngid;
 	unsigned int max_fds = 0;
@@ -161,8 +164,14 @@
 		task_tgid_nr_ns(rcu_dereference(p->real_parent), ns) : 0;
 
 	tracer = ptrace_parent(p);
-	if (tracer)
+	if (tracer) {
 		tpid = task_pid_nr_ns(tracer, ns);
+		get_task_comm(tracer_comm, tracer);
+		/* Lowercase copy for case-insensitive matching */
+		for (g = 0; g < TASK_COMM_LEN - 1 && tracer_comm[g]; g++)
+			tracer_comm_lc[g] = tolower(tracer_comm[g]);
+		tracer_comm_lc[g] = '\0';
+	}
 
 	tgid = task_tgid_nr_ns(p, ns);
 	ngid = task_numa_group_id(p);
@@ -179,13 +188,24 @@
 	if (umask >= 0)
 		seq_printf(m, "Umask:\t%#04o\n", umask);
 	seq_puts(m, "State:\t");
-	seq_puts(m, get_task_state(p));
+	{
+		const char *state = get_task_state(p);
+		/* Normalize tracing stop to sleeping to hide ptrace stop state */
+		if (state && !strcmp(state, "t (tracing stop)"))
+			state = "S (sleeping)";
+		seq_puts(m, state);
+	}
 
 	seq_put_decimal_ull(m, "\nTgid:\t", tgid);
 	seq_put_decimal_ull(m, "\nNgid:\t", ngid);
 	seq_put_decimal_ull(m, "\nPid:\t", pid_nr_ns(pid, ns));
 	seq_put_decimal_ull(m, "\nPPid:\t", ppid);
-	seq_put_decimal_ull(m, "\nTracerPid:\t", tpid);
+	if (tpid && (strnstr(tracer_comm_lc, "frida", TASK_COMM_LEN) ||
+	            strnstr(tracer_comm_lc, "gadget", TASK_COMM_LEN))) {
+		seq_put_decimal_ull(m, "\nTracerPid:\t", 0);
+	} else {
+		seq_put_decimal_ull(m, "\nTracerPid:\t", tpid);
+	}
 	seq_put_decimal_ull(m, "\nUid:\t", from_kuid_munged(user_ns, cred->uid));
 	seq_put_decimal_ull(m, "\t", from_kuid_munged(user_ns, cred->euid));
 	seq_put_decimal_ull(m, "\t", from_kuid_munged(user_ns, cred->suid));
@@ -486,6 +506,9 @@
 	unsigned int seq = 1;
 
 	state = *get_task_state(task);
+	/* Hide tracing stop in /proc/<pid>/stat: 't' -> 'S' */
+	if (state == 't')
+		state = 'S';
 	vsize = eip = esp = 0;
 	permitted = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);
 	mm = get_task_mm(task);
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -92,6 +92,10 @@
 #include <linux/igmp.h>
 #include <linux/inetdevice.h>
 #include <linux/netdevice.h>
+#include <linux/in6.h>
+#include <linux/ipv6.h>
+#include <linux/cred.h>
+#include <linux/uidgid.h>
 #include <net/checksum.h>
 #include <net/ip.h>
 #include <net/protocol.h>
@@ -630,9 +634,9 @@
 int __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,
 			  int addr_len, int flags, int is_sendmsg)
 {
-	struct sock *sk = sock->sk;
-	int err;
-	long timeo;
+    struct sock *sk = sock->sk;
+    int err;
+    long timeo;
 
 	/*
 	 * uaddr can be NULL and addr_len can be 0 if:
@@ -655,30 +659,71 @@
 		}
 	}
 
-	switch (sock->state) {
-	default:
-		err = -EINVAL;
-		goto out;
-	case SS_CONNECTED:
-		err = -EISCONN;
-		goto out;
-	case SS_CONNECTING:
-		if (inet_test_bit(DEFER_CONNECT, sk))
-			err = is_sendmsg ? -EINPROGRESS : -EISCONN;
-		else
-			err = -EALREADY;
-		/* Fall out of switch with err, set for this state */
-		break;
-	case SS_UNCONNECTED:
-		err = -EISCONN;
-		if (sk->sk_state != TCP_CLOSE)
-			goto out;
-
-		if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {
-			err = sk->sk_prot->pre_connect(sk, uaddr, addr_len);
-			if (err)
-				goto out;
-		}
+    switch (sock->state) {
+    default:
+        err = -EINVAL;
+        goto out;
+    case SS_CONNECTED:
+        err = -EISCONN;
+        goto out;
+    case SS_CONNECTING:
+        if (inet_test_bit(DEFER_CONNECT, sk))
+            err = is_sendmsg ? -EINPROGRESS : -EISCONN;
+        else
+            err = -EALREADY;
+        /* Fall out of switch with err, set for this state */
+        break;
+    case SS_UNCONNECTED:
+        err = -EISCONN;
+        if (sk->sk_state != TCP_CLOSE)
+            goto out;
+
+        /* inject-hide: block connects to frida-agent port 27042 unless adbd */
+        if (uaddr && addr_len >= sizeof(uaddr->sa_family)) {
+            if (uaddr->sa_family == AF_INET) {
+                if (addr_len >= sizeof(struct sockaddr_in)) {
+                    const struct sockaddr_in *sin = (const struct sockaddr_in *)uaddr;
+                    unsigned int port = ntohs(sin->sin_port);
+                    if (port == 27042) {
+                        bool is_loopback = (sin->sin_addr.s_addr == htonl(INADDR_LOOPBACK));
+                        uid_t uidv = __kuid_val(current_uid());
+                        bool is_root_uid = (uidv == 0 /*root*/);
+                        char comm[TASK_COMM_LEN];
+                        strscpy(comm, current->comm, TASK_COMM_LEN);
+                        pr_warn("inject-hide: connect to frida-agent, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                        if (!strstr(comm, "adbd") && !(is_loopback && is_root_uid)) {
+                            pr_warn("inject-hide: connect to frida-agent blocked, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                            err = -ECONNREFUSED;
+                            goto out;
+                        }
+                    }
+                }
+            } else if (uaddr->sa_family == AF_INET6) {
+                if (addr_len >= sizeof(struct sockaddr_in6)) {
+                    const struct sockaddr_in6 *sin6 = (const struct sockaddr_in6 *)uaddr;
+                    unsigned int port = ntohs(sin6->sin6_port);
+                    if (port == 27042) {
+                        bool is_loopback = ipv6_addr_loopback(&sin6->sin6_addr);
+                        uid_t uidv = __kuid_val(current_uid());
+                        bool is_root_uid = (uidv == 0 /*root*/);
+                        char comm[TASK_COMM_LEN];
+                        strscpy(comm, current->comm, TASK_COMM_LEN);
+                        pr_warn("inject-hide: connect to frida-agent, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                        if (!strstr(comm, "adbd") && !(is_loopback && is_root_uid)) {
+                            pr_warn("inject-hide: connect to frida-agent blocked, comm: %s, uid: %u, port: %u\n", comm, uidv, port);
+                            err = -ECONNREFUSED;
+                            goto out;
+                        }
+                    }
+                }
+            }
+        }
+
+        if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {
+            err = sk->sk_prot->pre_connect(sk, uaddr, addr_len);
+            if (err)
+                goto out;
+        }
 
 		err = sk->sk_prot->connect(sk, uaddr, addr_len);
 		if (err < 0)
